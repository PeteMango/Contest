Instructions

Your task is to implement a simplified version of an in-memory database. All operations that should be supported by this database are described below.

Solving this task consists of several levels. Subsequent levels are opened when the current level is correctly solved. You always have access to the data for the current and all previous levels.

You can execute a single test case by running the following command in the terminal: bash run_single_test.sh "<test_case_name>".
Requirements

Your task is to implement a simplified version of an in-memory database. Plan your design according to the level specifications below:

    Level 1: In-memory database should support basic operations to manipulate records, fields, and values within fields.
    Level 2: In-memory database should support displaying a specific record's fields based on a filter.
    Level 3: In-memory database should support TTL (Time-To-Live) configurations on database records.
    Level 4: In-memory database should support backup and restore functionality.

To move to the next level, you need to pass all the tests at this level.
Level 4

The database should be backed up from time to time. Introduce operations to support backing up and restoring the database state based on timestamps. When restoring, ttl expiration times should be recalculated accordingly.

    backup(self, timestamp: int) -> int — should save the database state at the specified timestamp, including the remaining ttl for all records and fields. Remaining ttl is the difference between their initial ttl and their current lifespan (the duration between the timestamp of this operation and their initial timestamp). Returns the number of non-empty non-expired records in the database.

    restore(self, timestamp: int, timestamp_to_restore: int) -> None — should restore the database from the latest backup before or at timestamp_to_restore. It's guaranteed that a backup before or at timestamp_to_restore will exist. Expiration times for restored records and fields should be recalculated according to the timestamp of this operation - since the database timeline always flows forward, restored records and fields should expire after the timestamp of this operation, depending on their remaining ttls at backup.

Examples

The example below shows how these operations should work (the section is scrollable to the right):
Queries	Explanations

set_at_with_ttl("A", "B", "C", 1, 10)

backup(3)
set_at("A", "D", "E", 4)
backup(5)
delete_at("A", "B", 8)
backup(9)
restore(10, 7)




backup(11)
scan_at("A", 15)
scan_at("A", 16)



database state: {"A": {"B": "C"}}
  with lifespan `[1, 11)`, meaning that the record should be deleted at timestamp = 11.
returns 1; saves the database state
database state: {"A": {"D": "E", "B": "C"}}
returns 1; saves the database state
returns True; database state: {"A": {"D": "E"}}
returns 1; saves the database state
restores the database to state of last backup at timestamp = 5:
  {"A": {"D": "E", "B": "C"}}
  with {"B": "C"} expiring at timestamp = 16: Since the initial ttl of the field is 10
  and the database was restored to the state at timestamp = 5; this field has had
  a lifespan of 4 and a remaining ttl of 6, so it will now expire at timestamp = 10 + 6 = 16.
returns 1; saves the database state
returns ["B(C)", "D(E)"]
returns ["D(E)"]

    [execution time limit] 3 seconds

    [memory limit] 1 GB
